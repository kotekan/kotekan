import numpy as np
import re
import click
import tempfile
from subprocess import check_call, CalledProcessError
from shutil import rmtree
import time


class Timespec:
    """ Emulate C `timespec` struct. """

    def __init__(self, tv_sec, tv_nsec=None):
        if tv_nsec is None:
            self.tv_sec = np.floor(tv_sec)
            self.tv_nsec = int((tv_sec - self.tv_sec) * 1e9)
        else:
            self.tv_sec = tv_sec
            self.tv_nsec = tv_nsec

    def __repr__(self):
        return 'tv_sec={:.1f}, tv_nsec={:.1f}'.format(self.tv_sec, self.tv_nsec)


class Polyco:
    """ Hold a pulsar timing solution and provide time of arrival predictions. """

    def __init__(self, tmid, dm, phase_ref, f0, coeff):
        self.tmid = tmid
        self.dm = dm
        self.phase_ref = phase_ref
        self.f0 = f0
        self.coeff = coeff

    def mjd2phase(self, t):
        dt = (t - self.tmid) * 1440
        phase = self.phase_ref + dt*60*self.f0
        for i in range(len(self.coeff)):
            phase += self.coeff[i] * dt**i

        return phase

    def unix2phase(self, t):
        t_mjd = unix2mjd(t)

        return self.mjd2phase(t_mjd)

    def next_toa(self, t, freq):
        # Adjust time for dispersion delay
        dm_delay = 4140. * self.dm * freq**(-2)
        psr_t = add_nsec(t, - dm_delay * 1e9)

        phase = self.unix2phase(psr_t)

        # time until next pulse in s
        return (1. - (phase - np.floor(phase))) / self.f0


def add_nsec(t, nsec):
    nsec_sum = int(t.tv_nsec + nsec)
    return Timespec(t.tv_sec + nsec_sum // 1000000000,
                    nsec_sum % 1000000000)


def unix2mjd(t):
    # number of days between UNIX epoch and MJD epoch is 40587
    return (t.tv_sec / 86400.) + (t.tv_nsec / 86400. / 1e9) + 40587


def mjd2unix(t):
    t_unix = (t - 40587.) * 86400
    return Timespec(int(t_unix), (t_unix - int(t_unix)) * 1e9)


class PolycoFile:
    """ Read a polyco file generated by TEMPO2 in the `newpolyco.dat` format. """

    head_type = [('name', str), ('date', str), ('UTC', str),
                 ('TMID', float), ('DM', float), ('doppler', float), ('log10rms', float),
                 ('RPHASE', float), ('F0', float), ('obs', str),
                 ('span', float), ('num_coeff', int), ('freq', float), ('bin_phase', float)]

    def __init__(self, fname):
        self.polyco_specs = []
        self.polycos = []
        self.dm = None
        with open(fname, 'r') as fh:
            line = fh.readline()
            while line != '':
                if line[:6] == 'TEMPO2':
                    # read header
                    new_header = {}
                    for i in range(len(self.head_type)):
                        line = fh.readline()
                        if self.head_type[i][0] == 'bin_phase':
                            continue
                        new_header[self.head_type[i][0]] = self.head_type[i][1](line.strip())
                    self.polyco_specs.append(new_header)
                    # read coeffecients
                    coeff = []
                    for i in range(new_header['num_coeff']):
                        line = fh.readline()
                        coeff.append(float(line.strip()))
                    params = [new_header[k] for k in ('TMID', 'DM', 'RPHASE', 'F0')] + [coeff, ]
                    self.polycos.append(Polyco(*params))
                line = fh.readline()
        self.tmid = np.array([p['TMID'] for p in self.polyco_specs])
        self.spans = np.array([
                np.array((-0.5, 0.5)) * self.polyco_specs[i]['span'] / 60. / 24. + self.tmid[i]
                for i in range(len(self.tmid))
            ])

    def get_closest(self, t):
        return self.polycos[np.argmin(np.abs(self.tmid - t))]

    def config_block(self, start_t, end_t=None):
        if end_t is not None:
            ind = np.argmax(np.array([min(end_t, s[1]) - max(start_t, s[0]) for s in self.spans]))
            poly = self.polycos[ind]
        else:
            poly = self.get_closest(start_t)

        return ("coeff: {}\n".format(poly.coeff) +
                "t_ref: {}\n".format(poly.tmid) +
                "phase_ref: {}\n".format(poly.phase_ref) +
                "rot_freq: {}\n".format(poly.f0) +
                "dm: {}".format(poly.dm if self.dm is None else self.dm))

    @classmethod
    def generate(cls, start, end, parfile, dm=None, seg=300., ncoeff=12, max_ha=12.):

        cmd = [
            'tempo2', '-f', parfile, '-polyco',
            '"{:f} {:f} {:d} {:d} {:f} chime inf"'.format(start, end, int(seg), ncoeff, max_ha),
            '-tempo1'
        ]
        cmd = ' '.join(cmd)

        tmp_dir = tempfile.mkdtemp()
        try:
            check_call(cmd, cwd=tmp_dir, shell=True)
        except CalledProcessError as e:
            print("Command '{}' failed with return code {:d}.".format(e.cmd, e.returncode))
            print(e.output)
            rmtree(tmp_dir)
            return None

        new_polyco = cls(tmp_dir + "/newpolyco.dat")
        if dm is not None:
            new_polyco.dm = dm

        rmtree(tmp_dir)

        return new_polyco


@click.group()
def cli():
    pass


@click.command()
@click.argument('unixtime', required=False, default=None, type=float)
def mjd(unixtime):
    """ Convert unix time to MJD.
        Will print MJD now if no time is provided. """
    if unixtime is None:
        ts = Timespec(time.time())
    else:
        ts = Timespec(unixtime)
    click.echo(unix2mjd(ts))


@click.command()
@click.argument("fname", type=str)
@click.argument("start-time", type=float)
@click.option("--generate-polyco", is_flag=True,
              help="If enabled, input file must be a pulsar parfile.")
@click.option("--end-time", type=float, default=None,
              help="Specify an end time to generate polyco / match segment with maximum overlap")
@click.option("--dm", type=float, default=None,
              help="The DM in cm^-3/pc. If not specified will try and get from file.")
@click.option("--segment", type=float, default=300,
              help="(generate-polyco) Length of polyco segments in minutes (default 300).")
@click.option("--ncoeff", type=int, default=12,
              help="(generate-polyco) Number of polyco coefficients to generate.")
@click.option("--max_ha", type=float, default=12.,
              help="(generate-polyco) Maximum hour angle for timing solution to span.")
def polyco_config(fname, start_time, generate_polyco, end_time, dm, segment, ncoeff, max_ha):
    if generate_polyco:
        if end_time is None:
            end = start_time + 1.
        else:
            end = end_time
        pfile = PolycoFile.generate(start_time, end, fname, dm, segment, ncoeff, max_ha)
    else:
        pfile = PolycoFile(fname)

    if pfile is None:
        print("\nCould not generate/read polyco file.")
        return

    if dm is not None:
        pfile.dm = dm

    print("\nSpan of solution is {:.3f} MJD.".format(segment/1440.))

    print("\nConfig block:\n")
    print(pfile.config_block(start_time, end_time))


if __name__ == '__main__':
    cli.add_command(polyco_config)
    cli.add_command(mjd)

    cli()
