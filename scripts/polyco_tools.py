import numpy as np
import re
import click


class Timespec:
    """ Emulate C `timespec` struct. """

    def __init__(self, tv_sec, tv_nsec=None):
        if tv_nsec is None:
            self.tv_sec = np.floor(tv_sec)
            self.tv_nsec = int((tv_sec - self.tv_sec) * 1e9)
        else:
            self.tv_sec = tv_sec
            self.tv_nsec = tv_nsec

    def __repr__(self):
        return 'tv_sec={:.1f}, tv_nsec={:.1f}'.format(self.tv_sec, self.tv_nsec)


class Polyco:
    """ Hold a pulsar timing solution and provide time of arrival predictions. """

    def __init__(self, tmid, dm, phase_ref, f0, coeff):
        self.tmid = tmid
        self.dm = dm
        self.phase_ref = phase_ref
        self.f0 = f0
        self.coeff = coeff

    def mjd2phase(self, t):
        dt = (t - self.tmid) * 1440
        phase = self.phase_ref + dt*60*self.f0
        for i in range(len(self.coeff)):
            phase += self.coeff[i] * dt**i

        return phase

    def unix2phase(self, t):
        t_mjd = unix2mjd(t)

        return self.mjd2phase(t_mjd)

    def next_toa(self, t, freq):
        # Adjust time for dispersion delay
        dm_delay = 4140. * self.dm * freq**(-2)
        psr_t = add_nsec(t, - dm_delay * 1e9)

        phase = self.unix2phase(psr_t)

        # time until next pulse in s
        return (1. - (phase - np.floor(phase))) / self.f0


def add_nsec(t, nsec):
    nsec_sum = int(t.tv_nsec + nsec)
    return Timespec(t.tv_sec + nsec_sum // 1000000000,
                    nsec_sum % 1000000000)


def unix2mjd(t):
    # number of days between UNIX epoch and MJD epoch is 40587
    return (t.tv_sec / 86400.) + (t.tv_nsec / 86400. / 1e9) + 40587


def mjd2unix(t):
    t_unix = (t - 40587.) * 86400
    return Timespec(int(t_unix), (t_unix - int(t_unix)) * 1e9)


class PolycoFile:
    """ Read a polyco file generated by TEMPO2 in the `newpolyco.dat` format. """

    head_type = [('name', str), ('date', str), ('UTC', str),
                 ('TMID', float), ('DM', float), ('doppler', float), ('log10rms', float),
                 ('RPHASE', float), ('F0', float), ('obs', str),
                 ('span', float), ('num_coeff', int), ('freq', float), ('bin_phase', float)]

    def __init__(self, fname):
        self.polyco_specs = []
        self.polycos = []
        with open(fname, 'r') as fh:
            line = fh.readline()
            while line != '':
                if line[:6] == 'TEMPO2':
                    # read header
                    new_header = {}
                    for i in range(len(self.head_type)):
                        line = fh.readline()
                        if self.head_type[i][0] == 'bin_phase':
                            continue
                        new_header[self.head_type[i][0]] = self.head_type[i][1](line.strip())
                    self.polyco_specs.append(new_header)
                    # read coeffecients
                    coeff = []
                    for i in range(new_header['num_coeff']):
                        line = fh.readline()
                        coeff.append(float(line.strip()))
                    params = [new_header[k] for k in ('TMID', 'DM', 'RPHASE', 'F0')] + [coeff, ]
                    self.polycos.append(Polyco(*params))
                line = fh.readline()
        self.tmid = np.array([p['TMID'] for p in self.polyco_specs])
        self.spans = np.array([
                np.array((-0.5, 0.5)) * self.polyco_specs[i]['span'] / 24. + self.tmid[i]
                for i in range(len(self.tmid))
            ])

    def get_closest(self, t):
        return self.polycos[np.argmin(np.abs(self.tmid - t))]

    def config_block(self, start_t, end_t=None):
        if end_t is not None:
            ind = np.argmin(np.array([min(end_t, s[1]) - max(start_t, s[0]) for s in self.spans]))
            poly = self.polycos[ind]
        else:
            poly = self.get_closest(start_t)

        return ("coeff: {}\n".format(poly.coeff) +
                "t_ref: {}\n".format(poly.tmid) +
                "phase_ref: {}\n".format(poly.phase_ref) +
                "rot_freq: {}\n".format(poly.f0) +
                "dm: {}".format(poly.dm))


@click.command()
@click.argument("fname", type=str)
@click.argument("time", type=float)
@click.option("--end-time", type=float, default=None,
              help="Specify an end time to match polyco with maximum overlap")
def get_config_block(fname, time, end_time):
    pfile = PolycoFile(fname)
    if end_time is None:
        print(pfile.config_block(time))
    else:
        print(pfile.config_block(time, end_time))

if __name__ == '__main__':
    get_config_block()