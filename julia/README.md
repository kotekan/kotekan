# Kotekan Julia CUDA kernel generator

## Installing Julia

- Install [Julia](https://github.com/JuliaLang/juliaup). One easy way
  is to use [juliaup](https://github.com/JuliaLang/juliaup). Julia
  will be installed into the directory `.julia` in your home
  directory.
- Instantiate the Julia package dependencies.
  - Start Julia:
    ```sh
    cd julia
    julia --project=@.
    ```
    The `--project=@.` argument is important, it selects the current
    project, which is similar to a Python virtual environment.
  - Install all Julia package dependencies:
    ```Julia
    using Pkg
    Pkg.update()
    ```
    This might take a bit because Julia is quite independent, and will
    download its own version of the CUDA SDK. Precompiling the `Makie`
    plotting package will also take some time.
  - You are done! Type Control-D (or `exit()`) to leave the Julia REPL.

## Generating kernels

There are three kernels that are generated via Julia, each in several
variations. These are
- `bb`: Baseband beamformer
- `frb`: FRB beamformer
- `upchan`: Upchannelizer
The kernel algorithms are described in the `docs` directory.

All Julia-generated kernels are generated from C++ templates. These
templates are located in the `kernels` subdirectory. These templates
are meant to be updated when Kotekan's APIs changes.

It is easiest to generate the kernels via the respective scripts in
the `bin` directory. For example, running `bin/bb.sh` (re-)generates
all variants for the baseband beamformer. Apart from running the Julia
code generator these scripts also format the generated code nicely and
copy the generated files into the right location in Kotekan.

Generating kernels requires an Nvidia A-40 GPU to be present in the
system.

The code generator will also run a few brief self-tests of the
generated kernels.

The generated code lives in the `output-A40` directory. Everything in
that directory is autogenerated.
- The `*.out` file is a log file capturing the screen output produced
  while generating the kernel.
- The `*.jl` file contains the generated Julia code. It is almost
  readable, except that many lines are too long, and the code is quite
  repetitive since many statements are repeated from loop unrolling.
- The `*.ptx` file contains the generated PTX code. This is the code
  that will be run by Kotekan.
- The `*.sass` file contains the SASS (Shader ASSembly, the actual
  machine instructions) that the GPU will see. The SASS code is
  generated by the CUDA SDK from the PTX code. This file allows
  inspecting the generated assembler code to look for inefficiencies.
  It is otherwise unused.
- The `*.cxx` file is the Kotekan source file, generated by expanding
  the respective template.
- The `*.yaml` file contains a high-level description of the kernel
  parameters, both parameters used to specify details of the kernels,
  as well as parameters that were chosen automatically as the kernel
  was generated. This file is now unused since we generate complete
  Kotekan C++ files. However, it is still interesting because it
  describes the kernel parameters in a human-readable format.

## Modifying the C++ templates

The C++ templates are complete C++ source files, but some details have
been templated out. We are using
[Mustache](https://jverzani.github.io/Mustache.jl/dev/), a templating
(string replacement) library that indicates the holes in the template
via `{{{` `}}}` triple-"mustache" characters.

(Careful: Most of the Mustache documentation speaks of double-braces
to indicate replacements, and only mention in passing that this will
also html-ify the text. We cannot have this since `<` is better than
`&lt;` in C++ code.)

In addition to simple replacements Mustache also support loops and
conditionals. Here are some brief examples:

Simple replacement:
```C++
class cuda{{{kernel_name}}} : public cudaCommand {
```
becomes
```C++
class cudaBasebandBeamformer_pathfinder : public cudaCommand {
```

Loops are indicated via `#`:
```C++
    // Kernel arguments:
    {{#kernel_arguments}}
    static constexpr std::size_t {{{name}}}_length = {{{value}}};
    {{/kernel_arguments}}
```
becomes
```C++
    // Kernel arguments:
    static constexpr std::size_t A_length = 524288ULL;
    static constexpr std::size_t E_length = 536870912ULL;
    static constexpr std::size_t s_length = 16384ULL;
    static constexpr std::size_t J_length = 134217728ULL;
    static constexpr std::size_t info_length = 1048576ULL;
```
For this replacement, the Julia code generator defines a list called
`kernel_arguments`. Each element of that list is a dictionary with
keys `name` and `value` that define the respective replacements. In
YAML, this would look like
```YAML
kernel_arguments:
  - {name: A, value: 524288ULL}
  - {name: E, value: 536870912ULL}
  - ...
```

Conditionals are indicated either via a `#` (sic) or a `^`, depending on
whether the condition should be negated:
```C++
    // Host-side buffer arrays
    {{#memnames}}
    {{^hasbuffer}}
    std::vector<std::vector<std::uint8_t>> host_{{{name}}};
    {{/hasbuffer}}
    {{/memnames}}
```
becomes
```C++
    // Host-side buffer arrays
    std::vector<std::vector<std::uint8_t>> host_info;
```
This is a loop over the `memnames` array (that array name should
really be changed!), and each element has a `hasbuffer` boolean entry.
This code happens to define local (non-Kotekan) arrays to hold temporary
data. The respective data structure defined by Julia is
```YAML
memnames:
  - {name: A, type: int8, isoutput: false, hasbuffer: true}
  - {name: E, type: int4p4, isoutput: false, hasbuffer: true}
  - ...
  - {name: info, type: int32, isoutput: true, hasbuffer: false}
```
