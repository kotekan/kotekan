# Python 2/3 compatibility
from __future__ import (absolute_import, division,
                        print_function, unicode_literals)
from builtins import (ascii, bytes, chr, dict, filter, hex, input,
                      int, map, next, oct, open, pow, range, round,
                      str, super, zip)

import numpy as np
import click
import tempfile
from subprocess import check_call, CalledProcessError
from shutil import rmtree
import time


class Timespec(object):
    """ Emulate C `timespec` struct. """

    def __init__(self, tv_sec, tv_nsec=None):
        if tv_nsec is None:
            self.tv_sec = np.floor(tv_sec)
            self.tv_nsec = int((tv_sec - self.tv_sec) * 1e9)
        else:
            self.tv_sec = tv_sec
            self.tv_nsec = tv_nsec

    def __repr__(self):
        return 'tv_sec={:.1f}, tv_nsec={:.1f}'.format(self.tv_sec, self.tv_nsec)


class Polyco(object):
    """ Hold a pulsar timing solution and provide time of arrival predictions. """

    def __init__(self, tmid, dm, phase_ref, f0, coeff, seg=None):
        self.tmid = tmid
        self.dm = dm
        self.phase_ref = phase_ref
        self.f0 = f0
        self.coeff = coeff
        self.seg = seg

    def mjd2phase(self, t):
        dt = (t - self.tmid) * 1440
        phase = self.phase_ref + dt*60*self.f0
        for i in range(len(self.coeff)):
            phase += self.coeff[i] * dt**i

        return phase

    def unix2phase(self, t):
        t_mjd = unix2mjd(t)

        return self.mjd2phase(t_mjd)

    def next_toa(self, t, freq):
        # Adjust time for dispersion delay
        dm_delay = 4140. * self.dm * freq**(-2)
        psr_t = add_nsec(t, - dm_delay * 1e9)

        phase = self.unix2phase(psr_t)

        # time until next pulse in s
        return (1. - (phase - np.floor(phase))) / self.f0


def add_nsec(t, nsec):
    nsec_sum = int(t.tv_nsec + nsec)
    return Timespec(t.tv_sec + nsec_sum // 1000000000,
                    nsec_sum % 1000000000)


def unix2mjd(t):
    # number of days between UNIX epoch and MJD epoch is 40587
    return (t.tv_sec / 86400.) + (t.tv_nsec / 86400. / 1e9) + 40587


def mjd2unix(t):
    t_unix = (t - 40587.) * 86400
    return Timespec(int(t_unix), (t_unix - int(t_unix)) * 1e9)


class PolycoFile(object):
    """ Read a polyco file generated by TEMPO2 in the `newpolyco.dat` format. """

    head_type = [('name', str), ('date', str), ('UTC', str),
                 ('TMID', float), ('DM', float), ('doppler', float), ('log10rms', float),
                 ('RPHASE', float), ('F0', float), ('obs', str),
                 ('span', float), ('num_coeff', int), ('freq', float), ('bin_phase', float)]

    def __init__(self, fname):
        self.polyco_specs = []
        self.polycos = []
        self.dm = None
        with open(fname, 'r') as fh:
            line = fh.readline()
            while line != '':
                if line[:6] == 'TEMPO2':
                    # read header
                    new_header = {}
                    for i in range(len(self.head_type)):
                        line = fh.readline()
                        if self.head_type[i][0] == 'bin_phase':
                            continue
                        new_header[self.head_type[i][0]] = self.head_type[i][1](line.strip())
                    self.polyco_specs.append(new_header)
                    # read coeffecients
                    coeff = []
                    for i in range(new_header['num_coeff']):
                        line = fh.readline()
                        coeff.append(float(line.strip()))
                    params = [new_header[k] for k in ('TMID', 'DM', 'RPHASE', 'F0')] + [coeff, ]
                    params += [new_header['span']]
                    self.polycos.append(Polyco(*params))
                line = fh.readline()
        self.tmid = np.array([p['TMID'] for p in self.polyco_specs])
        for p in self.polyco_specs:
            if p['span'] != self.polyco_specs[0]['span']:
                raise Exception("Polycos in file {} have segments of".format(fname)
                                + " different lengths.")
        self.spans = np.array([
                np.array((-0.5, 0.5)) * self.polyco_specs[i]['span'] / 60. / 24. + self.tmid[i]
                for i in range(len(self.tmid))
            ])

    def get_closest(self, t):
        return self.polycos[np.argmin(np.abs(self.tmid - t))]

    def config_block(self, start_t, end_t=None):
        if end_t is not None:
            start_ind = np.argmin(np.abs(start_t - self.tmid))
            end_ind = np.argmin(np.abs(end_t - self.tmid))
            poly = self.polycos[start_ind:end_ind+1]
        else:
            poly = [self.get_closest(start_t)]

        return ("coeff: {}\n".format([ p.coeff for p in poly ]) +
                "t_ref: {}\n".format([ p.tmid for p in poly ]) +
                "phase_ref: {}\n".format([ p.phase_ref for p in poly ]) +
                "rot_freq: {}\n".format(poly[0].f0) +
                "dm: {}\n".format(poly[0].dm if self.dm is None else self.dm) +
                "segment: {}".format(poly[0].seg * 60))

    @classmethod
    def generate(cls, start, end, parfile, dm=None, seg=300., ncoeff=12, max_ha=12.):

        cmd = [
            'tempo2', '-f', parfile, '-polyco',
            '"{:f} {:f} {:d} {:d} {:f} chime inf"'.format(start, end, int(seg), ncoeff, max_ha),
            '-tempo1'
        ]
        cmd = ' '.join(cmd)

        tmp_dir = tempfile.mkdtemp()
        try:
            check_call(cmd, cwd=tmp_dir, shell=True)
        except CalledProcessError as e:
            print("Command '{}' failed with return code {:d}.".format(e.cmd, e.returncode))
            print(e.output)
            rmtree(tmp_dir)
            return None

        new_polyco = cls(tmp_dir + "/newpolyco.dat")
        if dm is not None:
            new_polyco.dm = dm

        rmtree(tmp_dir)

        return new_polyco


@click.group()
def cli():
    pass


@click.command()
@click.argument('unixtime', required=False, default=None, type=float)
def mjd(unixtime):
    """ Convert unix time to MJD.
        Will print MJD now if no time is provided. """
    if unixtime is None:
        ts = Timespec(time.time())
    else:
        ts = Timespec(unixtime)
    click.echo(unix2mjd(ts))


@click.command()
@click.argument("fname", type=str)
@click.argument("start-time", type=float)
@click.option("--generate-polyco", is_flag=True,
              help="If enabled, input file must be a pulsar parfile.")
@click.option("--end-time", type=float, default=None,
              help="Specify an end time to generate polyco / match segment with maximum overlap")
@click.option("--dm", type=float, default=None,
              help="The DM in cm^-3/pc. If not specified will try and get from file.")
@click.option("--segment", type=float, default=300,
              help="(generate-polyco) Length of polyco segments in minutes (default 300).")
@click.option("--ncoeff", type=int, default=12,
              help="(generate-polyco) Number of polyco coefficients to generate.")
@click.option("--max_ha", type=float, default=12.,
              help="(generate-polyco) Maximum hour angle for timing solution to span.")
def polyco_config(fname, start_time, generate_polyco, end_time, dm, segment, ncoeff, max_ha):
    if generate_polyco:
        if end_time is None:
            end = start_time + 1.
        else:
            end = end_time
        pfile = PolycoFile.generate(start_time, end, fname, dm, segment, ncoeff, max_ha)
    else:
        pfile = PolycoFile(fname)

    if pfile is None or len(pfile.polycos) == 0:
        print("\nCould not generate/read polyco file.")
        return

    if dm is not None:
        pfile.dm = dm

    print("\nConfig block:\n")
    print(pfile.config_block(start_time, end_time))


if __name__ == '__main__':
    cli.add_command(polyco_config)
    cli.add_command(mjd)

    cli()
